# [괄호](https://www.acmicpc.net/problem/9012)

## 📌 문제
괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다.

여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다.

### 입력
입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다.

### 출력
출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다.

### 예제 입력 1

     6
     (())())
     (((()())()
     (()())((()))
     ((()()(()))(((())))()
     ()()()()(()()())()
     (()((())()(

### 예제 출력 1

     NO
     NO
     YES
     NO
     YES
     NO




### 예제 입력 2

     3
     ((
     ))
     ())(()

### 예제 출력 2

     NO
     NO
     NO




### 🧰 풀이 과정

스택(Stack)을 활용하여 올바른 괄호문자열 검증

1. 문자열을 한 글자씩 순회하면서 규칙 적용

   - 스택이 비어있지 않고, 스택의 top이 '('이고 현재 문자가 ')'이면
     - 짝이 맞는 괄호이므로 pop 수행

   - 그 외의 경우
     - 현재 문자를 스택에 push


2. 모든 문자 처리 후 스택 상태 확인
   - 스택이 비어있다면 "YES" (모든 괄호가 올바르게 짝지어짐)
   - 스택에 문자가 남아있다면 "NO" (짝이 맞지 않는 괄호 존재)


3. 입출력 최적화
   - 여러 테스트 케이스의 결과를 한 번에 출력하기 위해 StringBuilder 사용



### 시간복잡도와 공간복잡도

      
      시간복잡도: O(T * N)
         - T개의 테스트 케이스에 대해
         - 각 문자열의 길이 N만큼 순회
         - Stack의 push, pop, peek 연산은 모두 O(1)
         - 따라서 전체 시간복잡도는 O(T * N)
      
      공간복잡도: O(N)
         - 각 테스트 케이스마다 최대 N개의 문자를 저장하는 Stack
         - StringBuilder는 T개의 결과 저장 -> O(T)
         - 따라서 전체 공간복잡도는 O(N), (N > T일 때, N이 지배적)



### ✨ 새롭게 배운 점
1. Stack을 활용한 괄호 검증
   - Stack의 LIFO(Last In First Out) 특성을 활용한 문제 해결
   - Stack의 push, pop, peek 연산의 효율적인 활용


2. Java 제네릭 타입 시스템
   - Primitive type(char)과 Wrapper class(Character)의 차이
   - Stack<Character> 사용 시 auto-boxing의 동작 이해


### 💡 성능 개선 포인트
1. 문자열 순회 방식 최적화

   ```java
   // 현재: toCharArray()로 새로운 배열 생성
   for (char ch : PS.toCharArray())
   
   // 개선: charAt() 사용으로 추가 메모리 할당 제거
   for (int i = 0; i < PS.length(); i++) {
      char ch = PS.charAt(i);
   }
   ```

2. Stack 대신 배열도 사용 가능

   ```java
   // 현재: Java의 Stack 클래스 사용
   Stack<Character> stack = new Stack<>();
   
   // 개선: 문자열 길이가 최대 50이므로 고정 크기 배열로 구현 가능
   char[] stack = new char[50];
   int top = -1;
   ```

- 이 문제의 경우 입력 크기가 작아서 이런 최적화가 큰 성능 차이를 만들진 않음 (대용량 처리 시엔 유의미)